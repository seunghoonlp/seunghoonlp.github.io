---
layout: post
title: '확장된 유클리드 호제법 (Extended Euclidean Algorithm)'
---

## 유클리드 호제법
우선 일반적인 유클리드 호제법부터 다뤄보자. 예를 들어 1071과 462의 최대공약수를 찾을 필요가 있을 때, 다음과 같은 재귀적 연산으로 쉽게 최대공약수를 계산해낼 수 있다.

$$
\begin{aligned}
1071 &= 2 \times 462 + 147 \\
462 &= 3 \times 147 + 21 \\
147 &= 7 \times 21 + 0 \\
\end{aligned}
$$

나머지가 0이 될 때까지 계산을 반복하면 나누는 수인 21이 1071과 462의 최대공약수가 된다. 유클리드 호제법의 원리나 유한성의 증명은 시각적으로 잘 정리된 자료가 많으므로 참고하면 될 것 같다.

## 확장된 유클리드 호제법
그렇다면 **확장된 유클리드 호제법(Extended Euclidean Algorithm)**은 무엇일까? 확장된 유클리드 호제법은 정수 $$a,b$$에 대해 부정방정식 $$ax+by=gcd(a,b)$$의 정수해 $$x,y$$를 찾는 알고리즘이다. 앞서 예로 들었던 1071과 462, 그리고 두 수의 최대공약수 21을 이용해 $$1071x + 462y = 21$$의 정수해를 찾아보자.

우리가 구하려는 해를 쉽게 알아보기 위해 $$1071=a$$, $$462=b$$로 두고 과정을 진행하자. 유클리드 호제법에서의 첫 번째 식인 $$1071 = 2 \times 462 + 147$$은 $$147 = a - 2b$$로 다시 쓸 수 있다. 

이 $$147 = a - 2b$$를 두 번째 식에 대입하면 $$b = 3 \times (a - 2b) + 21$$, $$21$$에 대해 다시 정리하면 $$21 = b - 3 \times (a - 2b) = -3a + 7b$$이다. 

앗, 여기서 $$-3a + 7b = 21$$라는 우리가 원하는 부정방정식의 정수해가 나왔다! 

지금까지 우리의 과정을 정리해보면 기존의 유클리드 호제법의 식에서 생기는 나머지를 끊임없이 $$a$$와 $$b$$로 나타내면 어느새 부정방정식의 해가 도출된다는 것을 확인할 수 있다. 그렇다면 이것을 코드로 나타내면 어떨까? 우선 유클리드 호제법의 경우 아주 간결한 한 줄의 코드만으로 표현해낼 수 있었다.

```cpp
int gcd(int a, int b) {return b ? gcd(b, a % b) : a;}
```

그렇다면 확장된 유클리드 호제법도 결국 유클리드 호제법을 응용한 것이므로 위 코드를 응용함으로써 구현할 수 있다는 생각이 든다. 우선 부정방정식의 해를 저장할 변수 $$x$$와 $$y$$가 필요할 것이다. 