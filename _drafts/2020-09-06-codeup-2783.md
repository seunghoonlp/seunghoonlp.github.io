---
layout: post
title: 'CodeUp #2783: 주빈이와 발라드'
---

## 문제

[CodeUp #2783](https://codeup.kr/problem.php?id=2783)

이 문제는 처음으로 직접 제작한 문제이다. 문제를 만들면서 Description을 작성하고 테스트 케이스를 만드는 과정이 생각보다 쉽지 않다는 걸 느끼게 되었다. 지금까지 제출된 코드를 보니 테스트 케이스를 좀 더 보강했다면 좋았을 걸 하는 생각도 든다...

### 주빈이와 발라드
주빈이와 내강이는 평소 음악을 들으며 헬스장에서 운동을 하는 것을 즐긴다. 주빈이는 수많은 음악 장르 중에서도 유독 발라드를 좋아해서, 운동을 할 때 가능한 한 많은 발라드를 듣지 않으면 불같이 화를 내는 습성을 가지고 있다.

이때 내강이는 주빈이를 위해 최대한 많은 발라드를 들려주어야 한다. 내강이가 가지고 있는 음악 CD는 여러 장르의 음악이 섞여있고, 내강이가 시작 트랙을 정하면 음악이 순차적으로 정해진 곡의 개수만큼 재생된다. 따라서 내강이는 최대한 많은 발라드를 들려주기 위한 CD의 시작 트랙을 정해야 한다. 

예를 들어 CD에 {발라드, 락, 락, 발라드, 발라드} 순으로 음악이 저장되어있고 3곡을 재생해야 한다면, 3번 락 트랙부터 재생하는 것이 발라드를 2곡이나 들을 수 있으므로 최선의 방법이다.

내강이는 CD 트랙을 옮기기 위해 CD 플레이어의 버튼을 여러 번 누르는 것은 번거롭기 때문에, 트랙 번호가 가장 작으면서도 최대한 많은 발라드를 들을 수 있는 시작 트랙을 정하고자 한다. 빨리 정하지 않으면 근손실이 올 것만 같다. 내강이를 도와주자!

### 입력
첫째 줄에 재생할 곡의 개수 $$S$$와 CD의 트랙 수 $$N$$이 주어진다. ($$S \leq N,\, 1 \leq N \leq 10^7$$)

이후 둘째 줄부터 $$N$$개의 줄에 걸쳐 트랙의 장르가 주어진다.

### 출력
가장 많은 발라드를 들을 수 있는 시작 트랙의 최솟값을 출력한다. 이 때 발라드가 한 곡도 없을 땐 $$0$$을 출력한다.

## 풀이

슬라이딩 윈도우 기법을 이용해 풀이하면 $$O(n)$$시간에 해결할 수 있다. 마치 Queue처럼 $$N$$ 크기의 구역을 정해놓고 원소를 하나씩 선입선출(FIFO)하면서 최댓값을 구해나가면 된다.

데이터를 처리할 때 `bitset`과 같은 효율적인 자료구조를 사용하고, 입력 데이터의 크기에 유의하여 문제를 풀이하면 간단하게 풀 수 있는 문제이다.

```cpp
#include <bits/stdc++.h>

using namespace std;

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(nullptr);
    int s, n;
    cin >> s >> n;

    bitset<10000000> b;

    int cnt = 0, idx = 0;
    for (int i = 0; i < s; ++i) {
        string ss;
        cin >> ss;
        if (ss == "Ballad") {
            cnt++;
            b[i] = true;
        }
    }

    int ans = cnt;

    for (int i = s; i < n; ++i) {
        string ss;
        cin >> ss;
        if (ss == "Ballad") {
            cnt++; b[i] = true;
        }
        if (b[i - s]) cnt--;
        if (cnt > ans) {
            ans = cnt; idx = i - s + 1;
        }
    }

    cout << idx + 1;
}
```