---
layout: post
title: 'Fast Inverse Square Root (고속 역제곱근)'
---

**Fast Inverse Square Root (고속 역제곱근)**은 제곱근의 역수(역제곱근)를 근사적으로 추정하는 알고리즘이다. 1999년 "Quake III Arena"라는 FPS 게임의 코드에 등장함으로써 사람들에게 알려지게 되었는데, 그렇다면 왜 굳이 근사적인 값을 얻어가면서 역제곱근을 빨리 계산해야 했을까?

## 빠른 역제곱근 계산의 필요성
역제곱근의 계산은 주로 게임 업계에서 공간벡터의 정규화에 쓰였다. 벡터를 정규화(Normalize)하게 되면 벡터의 방향은 유지한 채 크기를 1로 만들 수 있고, 게임에선 빛의 반사 등을 계산하는 데 용이해지게 된다. 

예를 들어 $$v=(v_1,\, v_2,\, v_3)$$라는 벡터를 정규화하게 되면 식은 다음과 같다:

$$
\hat{v} = \frac{v}{\sqrt{v_1^2 + v_2^2 + v_3^2}}
$$

위 식에서 볼 수 있듯, $$\frac{1}{\sqrt{x}}$$ 꼴의 연산이 있으며, 3D게임의 경우 이 연산량은 어마어마하게 많아지게 된다. 따라서 당시의 컴퓨터로는 이 연산량을 감당하기에 무리가 있었기 때문에 고속 역제곱근 방법이 등장한 것이다.

## 어떻게 구현되어 있을까?
Quake III Arena에서의 원문 코드[^1]는 다음과 같다. (코드의 주석 역시 원문의 일부이다)

```cpp
float Q_rsqrt( float number )
{
	long i;
	float x2, y;
	const float threehalfs = 1.5F;

	x2 = number * 0.5F;
	y  = number;
	i  = * ( long * ) &y;  // evil floating point bit level hacking
	i  = 0x5f3759df - ( i >> 1 );  // what the fuck? 
	y  = * ( float * ) &i;
	y  = y * ( threehalfs - ( x2 * y * y ) );  // 1st iteration
//	y  = y * ( threehalfs - ( x2 * y * y ) );  // 2nd iteration, this can be removed

	return y;
}
```

동료 개발자의 주석에서 볼 수 있듯, 겉보기엔 역제곱근이 어떻게 계산되는 것인지 알 겨를이 없다. 이 코드를 이해하기 위해선 약간의 수학과 하드웨어적 지식이 필요하다. 하나씩 알아보도록 하자.

## 부동 소수점 (Floating Point)
컴퓨터가 실수를 저장하는 방식은 고정 소수점(Fixed Point)과 부동 소수점(Floating Point)로 나뉜다. 그 중 많이 사용되는 방식은 부동 소수점이다. 부동 소수점은 고정 소수점과 달리 소수점이 부동(浮動, Floating), 즉 떠다닌다는 의미를 가진다.

### IEEE 754
부동 소수점 표기법 중에서도 가장 많이 사용되는 것이 IEEE 754라는 전기 전자 공학자 협회의 표준안이다. 직접 이 표준안을 이용해 32비트 자료형에 $$0.15625$$를 표현해보자.

IEEE 754의 표현은 크게 세 부분으로 구성되는데, 바로 부호 비트(Sign Bit), 지수 부분(Exponent), 가수 부분(Mantissa)이다.

- 부호 비트: 0이면 양수, 1이면 음수를 나타낸다.
- 지수 부분: 수를 $$(1+M) \times 2^E$$로 표기했을 때 $$E$$에 편중치를 더한 값를 의미한다.
- 가수 부분: 수를 $$(1+M) \times 2^E$$로 표기했을 때 $$M$$를 의미한다.

지수 부분의 편중치에 대해선 나중에 설명하도록 하고, 우선 32비트 자료형에서는 0부터 수를 세었을 때 31번 비트가 신호 비트, 30 ~ 23번 비트가 지수 부분, 22 ~ 0번 비트가 가수 부분이 된다. 그림으로 나타내면 다음과 같다:

![IEEE 754 표기법 사진](/assets/images/fast_invsqrt/IEEE_754_single.png)

$$0.15625$$를 예로 들면 우선 양수이므로 부호 비트는 $$0$$이 되고, $$0.15625=(1+0.25) \times 2^{-3}$$이므로 지수 부분은 $$-3$$, 가수 부분은 $$0.25$$가 된다.

지수 부분이 음수인데 어떻게 비트로 표현할 수 있을까? 지수 부분 내에서 또 부호 비트를 만들어야 할까? IEEE 754에선 지수 부분에 편중치(Bias) $$127$$을 더해 양수로 만든 값을 비트에 저장하는 방법을 사용한다.

따라서 최종적으로 지수 부분은 $$124_{(10)} = 1111100_{(2)}$$, 가수 부분은 $$0.25_{(10)} = 0.01_{(2)}$$가 되어 비트에 위에서 보았던 그림처럼 비트에 넣을 수 있다.

사실 이 부동 소수점 표기에 대해선 더 많은 내용이 있지만, 고속 역제곱근 방법을 이해하기엔 이 정도 내용으로 충분하므로 여기서 넘어가도록 하자.

## 뉴턴-랩슨 방법 (Newton-Raphson Method)
뉴턴-랩슨 방법은 어떤 방정식의 근을 근사적으로 찾아낼 때 사용하는 알고리즘의 일종이다. 일단 $$f(x)=0$$에 대한 점화식만 알아보면,

$$
x_{n+1} = x_{n} - \frac{f(x_{n})}{f'(x_{n})}
$$

우리가 구하고자 하는 $$a$$의 역제곱근 값은 $$f(x) = \frac{1}{x^2}-a = 0$$을 만족하는 양의 $$x$$값이라는 것을 알 수 있다. 이 식을 뉴턴-랩슨 식에 대입하면

$$
x_{n+1} = x_n\left(\frac{3}{2}-\frac{a}{2} x_n^2 \right) = \frac{x_n(3-ax_n^2)}{2}
$$

그럼 위에서 살펴본 코드 중 다음 부분이 설명된다:
```cpp
const float threehalfs = 1.5F;
x2 = number * 0.5F;
y  = number;
// 중간 부분 생략
y  = y * ( threehalfs - ( x2 * y * y ) );  // 1st iteration
//	y  = y * ( threehalfs - ( x2 * y * y ) );  // 2nd iteration, this can be removed
```

식을 살펴보면 근을 찾아내기 위해선 초깃값 $$x_1$$이 필요하다는 것을 알 수 있는데, 초깃값이 근과 가까울 수록 근삿값이 근에 수렴하는 속도도 빨라진다. 즉, 빠른 역제곱근 방법은 Rough하게 역제곱근의 근사치를 계산한 후 뉴턴-랩슨 방법으로 보다 정확한 근을 찾는 방법인 것이다.

## 구분적 선형 근사로 역제곱근 구하기
코드를 보면 역제곱근의 근사치를 구하는 과정은 다음과 같다:

1. `float`형의 역제곱근을 구하고자 하는 수 $$x$$를 강제로 `int`형으로 읽는다
2. `0x5f3759df`에서 $$\left \lfloor{\frac{x}{2}}\right \rfloor$$의 값을 뺀다
3. `int`형의 수를 다시 `float`형으로 바꾼다

놀랍게도 이 과정만으로도 역제곱근의 근사적인 값이 도출된다. `0x5f3759df`는 Magic Number라 불리는 수로, 더 나은 Magic Number도 존재한다. 원문 코드에서 이 Magic Number가 어떻게 도출되었는지는 아직 알려져있지 않고, Chris Lomont의 논문[^2]에서는 계산 과정에서의 최대 상대오차 함수를 구해 수학 소프트웨어로 최대 상대오차값이 최소가 되는 지점을 찾음으로써 `0x5f3759df`와 유사한 Magic Number `0x5f37642f`를 구하는 과정이 소개되어 있다.

이 알고리즘의 원리는 구분적 선형 근사(Piecewise Linear Approximation)를 통해 해석할 수 있는데, 그 과정을 알아보도록 하자.

앞서 부동 소수점에 대해 설명하면서 $$0.15625_{(10)}$$를 부동 소수점 비트로 표현했을 때 지수 부분은 $$124_{(10)}$$, 가수 부분은 $$0.25_{(10)} = 0.01_{(2)}$$라고 했었다. 이 때 비트로 표현된 가수 부분은 뒷 부분의 남는 자리가 $$0$$으로 채워져있으므로 만약 가수 부분을 정수 그 자체로 읽은 수를 $$M$$이라고 한다면 실제 가수 부분이 의미하는 수 $$m$$은 여기서 23비트에 해당하는 양만큼 나눠준 $$m=\frac{M}{2^{23}}$$이 된다. 편의를 위해 앞으로 $$2^{23}$$은 $$L$$로 표기하도록 하자.

지수 부분의 경우 IEEE 754에서 더해준 편중치 $$127$$을 다시 빼주면 원래 지수 부분이 의미하는 수가 나온다. 원래 의미하는 수를 $$e$$, 정수 그대로 읽은 수를 $$E$$라고 한다면 관계식은 $$e=E-127$$이다. 편의를 위해 앞으로 $$127$$은 $$B$$로 표기하도록 하자.

위 내용을 다시 정리하면 주요 관계식은 다음과 같다.

$$
m=\frac{M}{L} \qquad e=E-B
$$

이 식을 이용해 부동 소수점 표기가 나타내는 실수는 $$(1+m)2^e$$로 나타낼 수 있다. 역제곱근을 구할 것이기 때문에 음수로 인한 부호 비트는 고려하지 않는다.

한편 부동 소수점으로 표기된 이 비트들을 `int`처럼 읽으면 그 수는 $$LE+M$$이다. 이 식을 잘 기억해두자! 앞서 부동 소수점을 설명하며 사용했던 그림을 참고하면서 이해할 수 있다.

$$x$$의 제곱근을 $$y$$라고 한다면 그 관계식은 $$y=\frac{1}{\sqrt{x}} = x^{-\frac{1}{2}}$$이다.
위 식을 부동 소수점 표기처럼 $$(1+m)2^e$$꼴로 나타내보자.

$$
(1+m_y)2^{e_y} = \{ (1+m_x)2^{e_x} \}^{-1/2}
$$

양변에 로그를 취하면 

$$
\log_2(1+m_y)+e_y = -\frac{1}{2}(\log_2(1+m_x)+e_x)
$$ 

$$m$$이 가수 부분이기 때문에 $$m \in [0,1)$$이다. 이 조건에서는 적절한 상수 $$\sigma$$에 대해 $$log_2(1+m) \simeq m+\sigma$$로 근사할 수 있다. 그래프를 보자.

![로그 선형 근사 그래프](/assets/images/fast_invsqrt/Figure_1.png)

적당히 비슷하다! 이 근사식으로 방금의 식을 표현해보자.

$$
m_y + \sigma + e_y \simeq -\frac{1}{2}(m_x + \sigma + e_x)
$$

지금 사용하고 있는 $$m$$이나 $$e$$는 부동 소수점 표기가 뜻하는 실수를 뜻하는 수이다. 위 코드에서 우린 이미 실수를 정수로 읽었으므로, $$m=\frac{M}{L}$$, $$e=E-B$$로 식을 다시 나타내자.

$$
\frac{M_y}{L} + \sigma + E_y - B \simeq -\frac{1}{2} \left(\frac{M_x}{L} + \sigma + E_x - B \right)
$$

식을 조금 정리해보면,

$$
\begin{aligned}
\frac{M_y}{L} + E_y &\simeq -\frac{1}{2} \left(\frac{M_x}{L} + \sigma + E_x - B \right) - \sigma + B \\
\frac{M_y}{L} + E_y &\simeq -\frac{1}{2} \left(\frac{M_x}{L} + E_x \right) - \frac{3}{2} \left( \sigma - B \right) \\
M_y + LE_y &\simeq \frac{3}{2}L(B-\sigma) - \frac{1}{2}\left(M_x + LE_x\right)
\end{aligned}
$$

앞서 언급했던 $$M + LE$$의 형태가 보인다. 이는 32비트 자료형 전체를 정수 형태로 읽었을 때 나타나는 수식이다. 이걸 $$I$$로 다시 표기해보면

$$
I_y \simeq \frac{3}{2}L(B - \sigma) - \frac{1}{2} I_x
$$

이 식에서 $$\frac{3}{2}L(B - \sigma)$$이 바로 Magic Number 이다. 이 $$\sigma$$에 적절한 값을 정해주면(원문 코드에선 0.0450465가 쓰였다) 고속 역제곱근의 이 코드가 설명된다. 

```cpp
i  = 0x5f3759df - ( i >> 1 );
```

이렇게 근사치를 구하고 나면, 뉴턴-랩슨 근사를 1 ~ 2번 진행하여 참값과 더 가까이 만들면 알고리즘이 완료된다.

## Magic Number
Chris Lomont의 Magic Number를 구하는 논문에서 볼 수 있듯, 수학적으로 계산된 Magic Number와 해당 알고리즘에서 쓰인 Magic Number는 차이가 있으며, 성능 또한 이 알고리즘에서 쓰인 Magic Number가 좀 더 좋다. 이런 현상이 발생하는 이유는 Magic Number의 계산 과정에서 뉴턴-랩슨 근사를 수행하는 과정을 고려하지 못했기 때문이고, 아마 처음 고속 역제곱근 방법을 고안한 사람도 설계할 때 수학적으로 Magic Number를 우선 구한 뒤, 시행착오를 거치면서 더 정확한 Magic Number를 찾아냈을 것이라 추측된다.

또한 이 고속 역제곱근 방법은 $$x^{-1/2}$$, 즉 지수가 $$-\frac{1}{2}$$일 때 계산된 방법이고, 지수가 $$-1 < x < 1$$ 범위 내라면 얼마든지 위와 같은 방법으로 응용될 수 있다.

## 마치며
현재는 하드웨어로 역제곱근을 빠르게 계산할 수 있는 환경이 만들어졌기 때문에 이런 소프트웨어 트릭은 더 이상 쓰이지 않고 있다. 하지만 이 알고리즘 자체가 수학과 하드웨어 지식을 신박하게 응용한 알고리즘이기 때문에, 한번쯤 살펴보면 좋은 알고리즘인 것 같다. 시간이 된다면 하드웨어에선 어떻게 역제곱근의 계산이 최적화되었는 지 찾아보고 싶다.

---
[^1]: [Quake III Arena 원문 코드](https://github.com/id-Software/Quake-III-Arena/blob/master/code/game/q_math.c#L552)
[^2]: [Chris Lomont, Fast Inverse Square Root](http://www.matrix67.com/data/InvSqrt.pdf)